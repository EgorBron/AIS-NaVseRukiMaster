
// Рассчитать начисления для оклада или премии, проведенные в регистре рассчета.
// 
// Параметры:
//  НаборЗаписейРегистра - РегистрРасчетаНаборЗаписей -  
//  ТребуемыйВидРассчета - ПланВидовРасчетаСсылка - 
//  СписокСотрудников - Массив из СтрокаТаблицыЗначений - 
Процедура РассчитатьНачисления(
	НаборЗаписейРегистра,
	ТребуемыйВидРассчета,
	СписокСотрудников
) экспорт
	// Задаем вспомогательные переменные,
	// в частности - условия для выбора текста запроса или формулы начислений
	Рег = НаборЗаписейРегистра.Отбор.Регистратор.Значение;
	ЭтоОклад = ТребуемыйВидРассчета = ПланыВидовРасчета.ОсновныеНачисления.Оклад;
	ЭтоПремия = ТребуемыйВидРассчета = ПланыВидовРасчета.ОсновныеНачисления.Премия;
	
	ЗапросИсходныхДанныхДляРассчета = новый Запрос;
	
	// Не запрещается уменьшить количество кода, так ведь?
	Если ЭтоОклад тогда // Для оклада выбирается:
		ЗапросИсходныхДанныхДляРассчета.Текст = "выбрать
		|	НачислГрафик.ЗначениеПериодДействия как Норма, // Норма отработки - график
		|	НачислГрафик.ЗначениеФактическийПериодДействия как Факт, // То, что отработано
		|	НачислГрафик.НомерСтроки как НомерСтроки // Ну и каким по счету идет этот период для графика
		|из РегистрРасчета.Начисления.ДанныеГрафика(Регистратор = &Регистратор // Таки выбираем в пределах дока-регистратора
		|	и ВидРасчета = &ВидРасчета и Сотрудник в (&СписокСотрудников) // Определенного расчета и нужного сотрудника
		|) как НачислГрафик";
	ИначеЕсли ЭтоПремия тогда // Но для премии:
		ЗапросИсходныхДанныхДляРассчета.Текст = "выбрать
		|	НачислБаза.РезультатБаза как База, // Мы берем то, что полагается выплатить
		|	НачислБаза.НомерСтроки как НомерСтроки // Не забывая про номер
		|из РегистрРасчета.Начисления.БазаНачисления(
		|	&ИзмеренияОсновного, &ИзмеренияБазового, , // 'Срезаем' по сотруднику, доку, ... эт цетера
		|	Регистратор = &Регистратор и ВидРасчета = &ВидРасчета и Сотрудник в (&СписокСотрудников)
		|) как НачислБаза";
		Измер = новый Массив(1);
		// Измер = новый Массив("Сотрудник"); // даже Visual Basic так не издевался
		Измер[0] = "Сотрудник";
		ЗапросИсходныхДанныхДляРассчета.УстановитьПараметр("ИзмеренияОсновного", Измер);
		ЗапросИсходныхДанныхДляРассчета.УстановитьПараметр("ИзмеренияБазового", Измер);
	конецесли;
	
	// И даже тут Visual Basic выиграл. Три слова, точнее оператора - With X \r\n Y End With.
	// Да что уж там, Pascal, Object Pascal, Delphi и иже подобные - with X do Y end; таки!
	// Уже молчу про языки современные. Где есть, где нет, а где нет, но так же нужен.
	ЗапросИсходныхДанныхДляРассчета
		.УстановитьПараметр("Регистратор", Рег); // Нам везде нужен отбор по доку-регистратору
	ЗапросИсходныхДанныхДляРассчета
		.УстановитьПараметр("ВидРасчета", ТребуемыйВидРассчета); // И только вот конкретный вид ПВР (премия, например)
	ЗапросИсходныхДанныхДляРассчета
		.УстановитьПараметр("СписокСотрудников", СписокСотрудников); // Ну и только избранные, коим нужен рассчет...
	Выборка = ЗапросИсходныхДанныхДляРассчета.Выполнить().Выбрать();
	
	// Во имя Нуралиева, весь скоп разработчиков ЯПа 1С - храни мягкую типизацию!
	// (это шутка, если что)
	// Но эта шутка позволяет уменьшить количество кода:
	// цикл ниже обрабатывает сразу две формулы для сходных запросов,
	// притом подход в книге Радченко по ясности ну явно проигрывает.
	Для каждого Запись из НаборЗаписейРегистра цикл
		// Сначала ищем такие же записи __в регистре__
		Номер = новый Структура("НомерСтроки");
		Номер.НомерСтроки = Запись.НомерСтроки;
		Выборка.Сбросить();
		
		Если Выборка.НайтиСледующий(Номер) тогда // И коли найдено - меняем по всем записям, где нужно рассчитать
			Если ЭтоОклад тогда
				Если Выборка.Норма = 0 Тогда
					Сообщения.Инфо("Вид расчета: Оклад — нет рабочих дней в заданном периоде");
					Запись.Результат = 0;
					Продолжить; // Нас не интересуют дальнейшие операции в цикле
				Иначе
					Запись.Результат = (Запись.ИсходныеДанные / Выборка.Норма) * Выборка.Факт;
				конецесли;
			ИначеЕсли ЭтоПремия тогда
				Запись.Результат = Выборка.База * 0.1 // 10% :)
			конецесли;
			
			Сообщения.Инфо(
					 "Выполнен расчет "
					 + Запись.Регистратор
					 + " – " + Запись.ВидРасчета
					 + " – " + Запись.Сотрудник);
		конецесли;
	конеццикла;
КонецПроцедуры


// Перерассчитать начисления, проведенные в регистре рассчета, по виду.
// 
// Параметры:
//  ТребуемыйВидРассчета - Строка - 
Процедура ПерерассчитатьНачисления(ТребуемыйВидРассчета) экспорт
	// Здесь мы по факту находим те записи, которые требуют перерасчет.
	// Код вроде требует комментариев... Но автор посчитал, что нужны только вопросы.
	Запрос = новый Запрос(
	"выбрать
	|	НачислПерерасчет.ОбъектПерерасчета,
	|	НачислПерерасчет.Сотрудник
	|из РегистрРасчета.Начисления.Перерасчет как НачислПерерасчет
	|где НачислПерерасчет.ВидРасчета = &ВидРасчета
	|итоги по НачислПерерасчет.ОбъектПерерасчета");
	Запрос.УстановитьПараметр("ВидРасчета", ТребуемыйВидРассчета);
	
	Сотрудники = новый СписокЗначений; // Стоит ли перенести в цикл? Сборщик мусора вроде же есть в 1С.
	
	ВыборкаПоРег = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоРег.Следующий() цикл
		Рег = ВыборкаПоРег.ОбъектПерерасчета;
		ВыборкаПоСотр = ВыборкаПоРег.Выбрать();
		Сотрудники.Очистить();
		Пока ВыборкаПоСотр.Следующий() цикл
			Сотрудники.Добавить(ВыборкаПоСотр.Сотрудник);
		конеццикла;
		
		НаборЗаписей = РегистрыРасчета.Начисления.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Значение = Рег;
		НаборЗаписей.Прочитать();
		
		// Ибо нефиг так делать - запросы да и в цикле.
		//@skip-check query-in-loop
		РассчитатьНачисления(НаборЗаписей, ТребуемыйВидРассчета, Сотрудники);
		НаборЗаписей.Записать(, Истина);
		
		НаборЗаписейПерерасчета = РегистрыРасчета.Начисления.Перерасчеты.Перерасчет.СоздатьНаборЗаписей();
		НаборЗаписейПерерасчета.Отбор.ОбъектПерерасчета.Значение = Рег;
		НаборЗаписейПерерасчета.Записать();
	конеццикла;
КонецПроцедуры

